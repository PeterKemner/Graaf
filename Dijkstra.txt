Dijkstra:

Graaf
-NogTeEvaluerenNodes: std::priority-queue<station*, std::vector<station*>,NodeComparable>
-Stations: std::vector<Station*>
-Vervoersmiddellen: std::array<bool,3> (mss enum)

Station
-name: std::string
-AfstandTotBron: int
-Vorige station: station*
-Stappen: std::vector<Stap>

+krijgBuren(vervoersmiddelen): std::vector<station*>

Stap (Treinrit, autorit, vlucht)
-Gewicht: int
-Oorsprong: station*
-Bestemming: station*

+virtual int getGewicht()=0
+virtual station* getOorsprong()=0
+virtual station* getBestemming()=0

stap is een virtual class

Class autorit : public Stap
+Autorit(gewicht, oorsprong, bestemming)
------------------------------------------
// stappen = {vlucht(),autorit(),treinrit(),&vlucht())
stappen = {&p_g}

Vlucht p_g = vlucht(&p, &g, 10)
station p = station("p")

--------------------------------------------
struct NodeComparable {
	bool operator()(const Node* lhs, const Node* rhs) const {
		return *lhs > *rhs;
	}
}

template<typename T>
struct Comparable {
	bool operator()(const T* lhs, const T* rhs) const {
		if (std::is_pointer<T>() == true {
			return *lhs > *rhs;
		}
		else {
			return lhs > rhs;
		}
	}
}

---------------------------
for(stap* s: stappen){
	typeof(*s)			(mss stap&, en s)

(enum switch case om te kijken 

std::aray<bool, 3> vm = {1,0,1}
// [0] = vlucht, [1] = trein, [2] = autorit


------------------------
void evalueerBuren(station* huidigstation) {
	for (stap& stap : huidigstation->stappen){
		if vehicletype 
		if (stap->bestemming->afstandtotbron > 
			huidigstation->afstandtotbron + stap->gewicht) {
			stap->bestemming->afstandtotbron = huidigstation->					afstandtotbron + stap->gewicht;
			stap->bestemming->vorigstation = huidigstation
			nogTeEvaluerenStations.push = stap->bestemming
		}
	}
}

dijkstra in Graaf
dijstra(station* startpunt, station* eindpunt, (vervoersmiddellen, hoeft niet)) {
	std::vector<station*> buren; 			(kan mss weg)
	nogTeEvaluerenStations.push(Startpunt)
	station* huidigstation;
	while(!nogTeEvaluerenStations.isEmpty()) {
		huidigstation = nogTeEvaluerenStations.top()
		evalueerBuren(huidigstation);
		nogTeEvaluerenStations.pop()
	return route;		(TODO)
}

a = end
while a != not source
	ps = a getpreviousstep
	vector.append ps.type, ps.destination, ps.weight
	a = ps.origin

You start in A
for (step in vector)
	cout you take step to dest

